/*
局部内部类访问局部变量必须用final修饰，为什么？
当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,
当方法被调用时会入栈,方法结束后即弹栈,这个局部变量也会消失,那么如果局部内部类对象还
没有马上消失想用这个局部变量,显然已无法使用了,如果用final修饰会在类加载时候进入常量
池,即使方法弹栈,常量池的常量还在,也可以继续使用了.
注意:在jdk1.8中取消了在局部内部类中使用的变量必须显示的final修饰,编译器默认会为你加上final

 内部类的作用
 每个内部类都能独立地继承自一个(接口的)实现,所以无论外部类是否已经继承了某个(接口的)实现,对于
 内部类都没有影响.如果没有内部类提供的可以继承多个具体的或抽象的类的能力,一些设计与编程问题就
 很难解决.从这个角度看,内部类使得多重继承的解决方案变得完整.接口解决了部分问题,而内部类有效地
 实现了"多重继承".
 -------------------------------
 成员:
 成员内部类
 静态内部类

 局部:
 匿名内部类
 方法内部类
 ------------------------------

依赖外部类对象的:成员内部类,方法内部类,匿名内部类
静态内部类不依赖外部类的对象.所以我们在项目中优先选择静态内部类.(不会出现内存泄漏的问题)
--------------------------------
 我们在项目开发中如果选择?


 */


public class Main {

    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
//间接实现多继承
class B{}
class C{}
class A extends B{
    class D extends C{}

}

